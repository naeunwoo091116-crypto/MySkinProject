from flask import Flask, render_template, request, jsonify
import torch
import torch.nn as nn
from torchvision import transforms, models
from PIL import Image
import io
import os
import json
from datetime import datetime
from pathlib import Path
from sqlalchemy.orm import Session
from models import engine, SessionLocal, User, AnalysisHistory, init_db
import numpy as np

# MediaPipe ì´ˆê¸°í™” - ì–¼êµ´ ê²€ì¦ ë¹„í™œì„±í™”
MEDIAPIPE_AVAILABLE = False
print("âš ï¸ MediaPipe ì–¼êµ´ ê²€ì¦ ë¹„í™œì„±í™” (ê¸°ë³¸ ê²€ì¦ë§Œ ì‚¬ìš©)")

app = Flask(__name__)

# ==========================================
# ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
# ==========================================
# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹œ í…Œì´ë¸” ìƒì„±
try:
    init_db()
    print("âœ… ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì„±ê³µ!")
except Exception as e:
    print(f"âš ï¸ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì˜¤ë¥˜: {e}")
    print("   JSON íŒŒì¼ ë°±ì—… ëª¨ë“œë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.")

def get_db():
    """ë°ì´í„°ë² ì´ìŠ¤ ì„¸ì…˜ ìƒì„±"""
    db = SessionLocal()
    try:
        return db
    except:
        db.close()
        raise

# ==========================================
# 1. ëª¨ë¸ í´ë˜ìŠ¤ ì •ì˜ (ë³´ë‚´ì£¼ì‹  êµ¬ì¡° ê·¸ëŒ€ë¡œ)
# ==========================================
class ResNetBalanced(nn.Module):
    def __init__(self, num_classes, num_regression_targets):
        super().__init__()
        
        # weights=None: ì„œë²„ ì‹¤í–‰ ì‹œ ë‹¤ìš´ë¡œë“œ ë°©ì§€ ë° ë¡œì»¬ ê°€ì¤‘ì¹˜ ì‚¬ìš©
        resnet = models.resnet34(weights=None) 
        self.features = nn.Sequential(*list(resnet.children())[:-1])

        self.classifier = nn.Sequential(
            nn.Flatten(),
            nn.Dropout(0.5),
            nn.Linear(512, 256),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(256, num_classes)
        )

        self.regressor = nn.Sequential(
            nn.Flatten(),
            nn.Dropout(0.5),
            nn.Linear(512, 384),
            nn.ReLU(),
            nn.BatchNorm1d(384),
            nn.Dropout(0.4),
            nn.Linear(384, 256),
            nn.ReLU(),
            nn.BatchNorm1d(256),
            nn.Dropout(0.3),
            nn.Linear(256, num_regression_targets)
        )

    def forward(self, x):
        x = self.features(x)
        return self.classifier(x), self.regressor(x)

# ==========================================
# 2. ë¶€ìœ„ë³„ íŒŒë¼ë¯¸í„° ì„¤ì • (ZONE_PARAMS ë°˜ì˜)
# ==========================================
# HTMLì—ì„œ ì‚¬ìš©í•˜ëŠ” ì´ë¦„(key)ê³¼ ì‚¬ìš©ìë‹˜ì˜ ì„¤ì •ì„ ì—°ê²°í–ˆìŠµë‹ˆë‹¤.
# íŒŒì¼ ê²½ë¡œ("models/xxxx.pth")ê°€ ì‹¤ì œ íŒŒì¼ëª…ê³¼ ë§ëŠ”ì§€ ê¼­ í™•ì¸í•˜ì„¸ìš”!
MODEL_CONFIGS = {
    "forehead": { # Zone 1
        "path": "models/forehead_model.pth",
        "num_classes": 4,
        "num_targets": 15
    },
    "eye_l": {    # Zone 3 (ì™¼ìª½ ëˆˆê°€)
        "path": "models/left_eye_model.pth",
        "num_classes": 4,
        "num_targets": 8
    },
    "eye_r": {    # Zone 4 (ì˜¤ë¥¸ìª½ ëˆˆê°€)
        "path": "models/right_eye_model.pth",
        "num_classes": 4,
        "num_targets": 8
    },
    "cheek_l": {  # Zone 5 (ì™¼ìª½ ë³¼)
        "path": "models/left_cheek_model.pth",
        "num_classes": 4,
        "num_targets": 16
    },
    "cheek_r": {  # Zone 6 (ì˜¤ë¥¸ìª½ ë³¼)
        "path": "models/right_cheek_model.pth",
        "num_classes": 4,
        "num_targets": 16
    },
    "chin": {     # Zone 8 (í„±)
        "path": "models/chin_model.pth",
        "num_classes": 4,
        "num_targets": 15
    }
}

device = torch.device('cpu')
loaded_models = {}

print("--- AI ëª¨ë¸ ë¡œë”© ì‹œì‘ (ë¶€ìœ„ë³„ ì„¤ì • ì ìš©) ---")

# ì„¤ì •ê°’(config)ì„ í•˜ë‚˜ì”© êº¼ë‚´ì„œ ëª¨ë¸ì„ ë§ì¶¤ ìƒì„±í•©ë‹ˆë‹¤.
for region_name, config in MODEL_CONFIGS.items():
    path = config["path"]
    n_cls = config["num_classes"]
    n_reg = config["num_targets"]

    try:
        if os.path.exists(path):
            print(f"ğŸ”„ ë¡œë”© ì¤‘: {region_name} (Class:{n_cls}, Reg:{n_reg})")
            
            # [í•µì‹¬ ë³€ê²½ ì‚¬í•­] ê° ë¶€ìœ„ì— ë§ëŠ” íŒŒë¼ë¯¸í„°ë¡œ ëª¨ë¸ ìƒì„±
            model = ResNetBalanced(num_classes=n_cls, num_regression_targets=n_reg)
            
            # ê°€ì¤‘ì¹˜ ë¡œë“œ
            checkpoint = torch.load(path, map_location=device)
            
            if isinstance(checkpoint, dict):
                if 'state_dict' in checkpoint:
                    state_dict = checkpoint['state_dict']
                elif 'model' in checkpoint:
                    state_dict = checkpoint['model']
                else:
                    state_dict = checkpoint
            else:
                state_dict = checkpoint
            
            model.load_state_dict(state_dict)
            model.eval() # í‰ê°€ ëª¨ë“œ (í•„ìˆ˜)
            
            loaded_models[region_name] = model
            print(f"âœ… {region_name} ë¡œë“œ ì„±ê³µ!")
        else:
            print(f"âŒ íŒŒì¼ ì—†ìŒ: {path}")
            
    except Exception as e:
        print(f"âš ï¸ {region_name} ë¡œë“œ ì‹¤íŒ¨: {e}")
        print(f"-> ì„¤ì •ê°’(num_classes={n_cls}, targets={n_reg})ì´ .pth íŒŒì¼ê³¼ ë§ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.")

# ì´ë¯¸ì§€ ì „ì²˜ë¦¬
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# ==========================================
# ìƒì„¸ í”¼ë¶€ ë¶„ì„ ë©”íŠ¸ë¦­ ë§¤í•‘
# ==========================================
# Regression ê°’ë“¤ì„ ì˜ë¯¸ ìˆëŠ” ì§€í‘œë¡œ ë³€í™˜
# ê° ë¶€ìœ„ë³„ë¡œ ë‹¤ë¥¸ ê°œìˆ˜ì˜ regression targetì„ ê°€ì§€ë¯€ë¡œ ìœ ì—°í•˜ê²Œ ì²˜ë¦¬
METRIC_NAMES = {
    "forehead": ["ì£¼ë¦„_ê¹Šì´", "ì£¼ë¦„_ë°€ë„", "ìƒ‰ì†Œì¹¨ì°©", "í”¼ë¶€í†¤_ê· ì¼ë„", "íƒ„ë ¥ë„", "ëª¨ê³µ_í¬ê¸°",
                 "í”¼ì§€_ë¶„ë¹„", "ìˆ˜ë¶„ë„", "ê±°ì¹ ê¸°", "í™ë°˜", "ê°ì§ˆ", "ê´‘íƒë„", "íˆ¬ëª…ë„", "ë¯¸ì„¸ì£¼ë¦„", "ì²˜ì§"],
    "eye_l": ["ì£¼ë¦„_ê¹Šì´", "ë‹¤í¬ì„œí´", "ë¶€ê¸°", "íƒ„ë ¥ë„", "ë¯¸ì„¸ì£¼ë¦„", "ìƒ‰ì†Œì¹¨ì°©", "ì²˜ì§", "ê±´ì¡°ë„"],
    "eye_r": ["ì£¼ë¦„_ê¹Šì´", "ë‹¤í¬ì„œí´", "ë¶€ê¸°", "íƒ„ë ¥ë„", "ë¯¸ì„¸ì£¼ë¦„", "ìƒ‰ì†Œì¹¨ì°©", "ì²˜ì§", "ê±´ì¡°ë„"],
    "cheek_l": ["ëª¨ê³µ_í¬ê¸°", "í”¼ì§€_ë¶„ë¹„", "ìƒ‰ì†Œì¹¨ì°©", "í™ë°˜", "íƒ„ë ¥ë„", "ì£¼ë¦„", "ìˆ˜ë¶„ë„", "í”¼ë¶€í†¤",
                "ê±°ì¹ ê¸°", "ê´‘íƒë„", "ê°ì§ˆ", "íˆ¬ëª…ë„", "ë¯¸ì„¸ì£¼ë¦„", "ì²˜ì§", "ì¡í‹°", "í˜ˆê´€"],
    "cheek_r": ["ëª¨ê³µ_í¬ê¸°", "í”¼ì§€_ë¶„ë¹„", "ìƒ‰ì†Œì¹¨ì°©", "í™ë°˜", "íƒ„ë ¥ë„", "ì£¼ë¦„", "ìˆ˜ë¶„ë„", "í”¼ë¶€í†¤",
                "ê±°ì¹ ê¸°", "ê´‘íƒë„", "ê°ì§ˆ", "íˆ¬ëª…ë„", "ë¯¸ì„¸ì£¼ë¦„", "ì²˜ì§", "ì¡í‹°", "í˜ˆê´€"],
    "chin": ["ì—¬ë“œë¦„", "í”¼ì§€_ë¶„ë¹„", "ëª¨ê³µ_í¬ê¸°", "ìƒ‰ì†Œì¹¨ì°©", "í™ë°˜", "íƒ„ë ¥ë„", "ê±°ì¹ ê¸°", "ê°ì§ˆ",
             "ìˆ˜ë¶„ë„", "í”¼ë¶€í†¤", "ë¯¸ì„¸ì£¼ë¦„", "ì²˜ì§", "ê´‘íƒë„", "íˆ¬ëª…ë„", "ì¡í‹°"]
}

def parse_regression_values(region_name, reg_values):
    """
    Regression ê°’ì„ ì˜ë¯¸ ìˆëŠ” ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜

    ëª¨ë¸ ì¶œë ¥ ë²”ìœ„ì— ë”°ë¼ ì ì‘í˜• ì •ê·œí™” ì ìš©:
    - ë§¤ìš° ì‘ì€ ê°’(0-1 ë²”ìœ„): 100ë°° ìŠ¤ì¼€ì¼ë§
    - ì¤‘ê°„ ê°’(0-10 ë²”ìœ„): 10ë°° ìŠ¤ì¼€ì¼ë§
    - í° ê°’(ê·¸ ì´ìƒ): ê·¸ëŒ€ë¡œ ì‚¬ìš©
    """
    metrics = METRIC_NAMES.get(region_name, [])
    parsed = {}

    # ì „ì²´ ê°’ì˜ ë²”ìœ„ í™•ì¸
    if reg_values:
        max_val = max(abs(v) for v in reg_values)

        # ì ì‘í˜• ìŠ¤ì¼€ì¼ íŒ©í„° ê²°ì •
        if max_val < 0.1:
            scale_factor = 1000  # ë§¤ìš° ì‘ì€ ê°’ (0~0.1 ë²”ìœ„)
        elif max_val < 1:
            scale_factor = 100   # ì‘ì€ ê°’ (0.1~1 ë²”ìœ„)
        elif max_val < 10:
            scale_factor = 10    # ì¤‘ê°„ ê°’ (1~10 ë²”ìœ„)
        else:
            scale_factor = 1     # ì´ë¯¸ ì ì ˆí•œ ë²”ìœ„

    for i, metric_name in enumerate(metrics):
        if i < len(reg_values):
            # ì ì‘í˜• ìŠ¤ì¼€ì¼ë§ ì ìš©
            raw_value = reg_values[i]
            normalized = max(0, min(100, abs(raw_value) * scale_factor))
            parsed[metric_name] = round(normalized, 1)  # ì†Œìˆ˜ì  1ìë¦¬

    return parsed

# ==========================================
# AI ê¸°ë°˜ LED ì¶”ì²œ ì—”ì§„ (í™•ì¥ ê°€ëŠ¥ ì„¤ê³„)
# ==========================================
class LEDRecommendationEngine:
    """
    Seeed Xiao BLE ë³´ë“œ LED í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ í™•ì¥ ê°€ëŠ¥í•œ ì¶”ì²œ ì‹œìŠ¤í…œ

    í˜„ì¬: ê¸°ë³¸ ê·œì¹™ ê¸°ë°˜ ì¶”ì²œ
    í–¥í›„ í™•ì¥:
    - BLE í†µì‹  í”„ë¡œí† ì½œ ì¶”ê°€
    - ì‹¤ì‹œê°„ ì„¼ì„œ í”¼ë“œë°± í†µí•©
    - ML ê¸°ë°˜ ê°œì¸í™” ì¶”ì²œ
    """

    # LED ëª¨ë“œ ì •ì˜ (í–¥í›„ Xiao BLE íŒì›¨ì–´ì™€ ë§¤í•‘)
    LED_MODES = {
        "red": {
            "wavelength": 630,
            "benefits": ["ì£¼ë¦„ê°œì„ ", "íƒ„ë ¥ì¦ì§„", "ì½œë¼ê²ìƒì„±"],
            "target_issues": ["wrinkle", "elasticity", "sagging"]
        },
        "blue": {
            "wavelength": 415,
            "benefits": ["ì—¬ë“œë¦„ì™„í™”", "ëª¨ê³µì§„ì •", "í”¼ì§€ì¡°ì ˆ"],
            "target_issues": ["acne", "pore", "sebum", "redness"]
        },
        "gold": {
            "wavelength": 590,
            "benefits": ["ë¯¸ë°±", "ìƒ‰ì†Œì™„í™”", "í”¼ë¶€í†¤ê°œì„ "],
            "target_issues": ["pigmentation", "tone", "dark_spot"]
        }
    }

    @staticmethod
    def recommend(analysis_results):
        """
        í”¼ë¶€ ë¶„ì„ ê²°ê³¼ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìµœì ì˜ LED ëª¨ë“œ ì¶”ì²œ

        Args:
            analysis_results: {"overall_score": int, "regions": {...}}

        Returns:
            {
                "mode": "red/blue/gold",
                "duration": int (ë¶„),
                "reason": str,
                "target_regions": [str],
                "intensity": int (0-100, í–¥í›„ BLE ì œì–´ìš©)
            }
        """
        regions = analysis_results.get("regions", {})
        overall_score = analysis_results.get("overall_score", 75)

        # 1. ë¶€ìœ„ë³„ ë¬¸ì œ ì ìˆ˜ ì§‘ê³„
        issue_scores = {
            "wrinkle": 0,
            "elasticity": 0,
            "pigmentation": 0,
            "acne": 0,
            "pore": 0
        }

        weak_regions = []

        for region_name, data in regions.items():
            score = data.get("score", 75)
            if score < 70:
                weak_regions.append(region_name)

            # ë¶€ìœ„ë³„ íŠ¹ì„±ì— ë”°ë¼ ë¬¸ì œ ìœ í˜• ê°€ì¤‘ì¹˜ ë¶€ì—¬
            if region_name in ["forehead", "eye_l", "eye_r"]:
                issue_scores["wrinkle"] += (100 - score) * 0.3
                issue_scores["elasticity"] += (100 - score) * 0.2
            elif region_name in ["cheek_l", "cheek_r"]:
                issue_scores["pore"] += (100 - score) * 0.25
                issue_scores["pigmentation"] += (100 - score) * 0.2
            elif region_name == "chin":
                issue_scores["acne"] += (100 - score) * 0.3

        # 2. ê°€ì¥ ì‹¬ê°í•œ ë¬¸ì œ ì°¾ê¸°
        main_issue = max(issue_scores, key=issue_scores.get)
        issue_severity = issue_scores[main_issue]

        # 3. LED ëª¨ë“œ ì„ íƒ
        if main_issue in ["acne", "pore"]:
            mode = "blue"
            reason = "ëª¨ê³µ ë° í”¼ì§€ ë¬¸ì œ ì§‘ì¤‘ ì¼€ì–´"
        elif main_issue in ["wrinkle", "elasticity"]:
            mode = "red"
            reason = "ì£¼ë¦„ ë° íƒ„ë ¥ ê°œì„  ì§‘ì¤‘"
        else:
            mode = "gold"
            reason = "ìƒ‰ì†Œ ì¹¨ì°© ë° í”¼ë¶€í†¤ ê°œì„ "

        # 4. ì‹œê°„ ì¡°ì • (ë¬¸ì œê°€ ì‹¬ê°í• ìˆ˜ë¡ ê¸¸ê²Œ)
        if issue_severity > 40:
            duration = 25
        elif issue_severity > 25:
            duration = 20
        else:
            duration = 15

        # 5. ê°•ë„ ê³„ì‚° (í–¥í›„ BLE PWM ì œì–´ìš©)
        intensity = min(100, max(50, int(issue_severity * 1.5)))

        return {
            "mode": mode,
            "duration": duration,
            "reason": reason,
            "target_regions": weak_regions,
            "intensity": intensity,
            "ble_command": f"START:{mode.upper()}:{duration}",  # Xiao BLE ì „ì†¡ìš© ëª…ë ¹ì–´ (í™•ì¥ ê°€ëŠ¥)
            "issue_analysis": {k: round(v, 2) for k, v in issue_scores.items()}
        }

    @staticmethod
    def get_device_config():
        """
        Seeed Xiao BLE ë””ë°”ì´ìŠ¤ ì„¤ì • ë°˜í™˜ (í–¥í›„ í™•ì¥ìš©)
        """
        return {
            "device_name": "MySkin_LED_Mask",
            "ble_service_uuid": "0000ffe0-0000-1000-8000-00805f9b34fb",
            "supported_modes": list(LEDRecommendationEngine.LED_MODES.keys()),
            "pwm_range": [0, 255],
            "firmware_version": "1.0.0"  # í–¥í›„ íŒì›¨ì–´ ë²„ì „ ì²´í¬ìš©
        }

# ==========================================
# 3. ì„œë²„ API
# ==========================================
@app.route('/')
def home():
    return render_template('index.html')

def is_valid_face_image(image):
    """
    ì–¼êµ´ ì´ë¯¸ì§€ ìœ íš¨ì„± ê²€ì‚¬ - MediaPipe Face Detection ì‚¬ìš© (v0.10+ New API)

    Args:
        image: PIL Image ê°ì²´ (RGB)

    Returns:
        (bool, str): (ìœ íš¨ ì—¬ë¶€, ì‹¤íŒ¨ ì´ìœ )
    """
    print("\n   ğŸ” [ì´ë¯¸ì§€ ê²€ì¦ ì‹œì‘]")

    try:
        # 1. ì´ë¯¸ì§€ í¬ê¸° í™•ì¸
        width, height = image.size
        print(f"   ğŸ“ ì´ë¯¸ì§€ í¬ê¸°: {width}x{height}")
        if width < 100 or height < 100:
            return False, "ì´ë¯¸ì§€ê°€ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤ (ìµœì†Œ 100x100)"

        # 2. ì´ë¯¸ì§€ë¥¼ numpy ë°°ì—´ë¡œ ë³€í™˜ (RGB)
        img_array = np.array(image, dtype=np.uint8)

        # 3. ë°ê¸° í™•ì¸
        mean_brightness = np.mean(img_array)
        print(f"   ğŸ’¡ í‰ê·  ë°ê¸°: {mean_brightness:.1f}")

        if mean_brightness < 20:
            return False, "ì´ë¯¸ì§€ê°€ ë„ˆë¬´ ì–´ë‘¡ìŠµë‹ˆë‹¤"
        if mean_brightness > 235:
            return False, "ì´ë¯¸ì§€ê°€ ë„ˆë¬´ ë°ìŠµë‹ˆë‹¤"

        print("   âœ… ì´ë¯¸ì§€ ê²€ì¦ í†µê³¼")
        return True, "OK"

    except Exception as e:
        print(f"âŒ ì´ë¯¸ì§€ ê²€ì¦ ì˜¤ë¥˜: {e}")
        import traceback
        traceback.print_exc()
        return False, f"ì´ë¯¸ì§€ ê²€ì¦ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"


@app.route('/api/v1/analysis/face', methods=['POST'])
def analyze_face():
    if 'file' not in request.files:
        return jsonify({"error": "No file"}), 400

    file = request.files['file']
    user_id = request.form.get('user_id', 'anonymous')

    try:
        # 1. ì´ë¯¸ì§€ ì½ê¸°
        image_bytes = file.read()
        original_image = Image.open(io.BytesIO(image_bytes)).convert('RGB')
        input_tensor = transform(original_image).unsqueeze(0)

        print("\n" + "="*50)
        print(f"ğŸ“¸ [AI ë¶„ì„ ì‹œì‘] ì‚¬ìš©ì: {user_id} | ì´ë¯¸ì§€: {original_image.size}")
        print("="*50)

        # 2. ì–¼êµ´ ìœ íš¨ì„± ê²€ì‚¬ (MediaPipe)
        is_valid, reason = is_valid_face_image(original_image)
        if not is_valid:
            print(f"âŒ ì–¼êµ´ ê²€ì¦ ì‹¤íŒ¨: {reason}")
            return jsonify({
                "error": "invalid_image",
                "message": reason,
                "details": "ì–¼êµ´ì´ í¬í•¨ëœ ì‚¬ì§„ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”."
            }), 400

        print("âœ… ì–¼êµ´ ê²€ì¦ í†µê³¼")

        results = {}
        total_grade_sum = 0
        count = 0

        # ì •ì˜ëœ ëª¨ë“  ë¶€ìœ„ë¥¼ ìˆœíšŒ
        for region_name, config in MODEL_CONFIGS.items():
            if region_name in loaded_models:
                with torch.no_grad():
                    # AI ëª¨ë¸ ì‹¤í–‰
                    cls_out, reg_out = loaded_models[region_name](input_tensor)

                    # --- [ê²€ì¦ 1] Classification (ë“±ê¸‰) ---
                    probs = torch.softmax(cls_out, dim=1)
                    _, predicted_idx = torch.max(cls_out, 1)
                    grade = predicted_idx.item() + 1

                    # --- [ê²€ì¦ 2] Regression (ìƒì„¸ ìˆ˜ì¹˜) ---
                    reg_values = reg_out[0].tolist()

                    # í„°ë¯¸ë„ì— ë¡œê·¸ ì°ê¸°
                    print(f"ğŸ” [{region_name.upper()}] ë¶„ì„ ê²°ê³¼")
                    print(f"   - ë“±ê¸‰(Class): {grade}ë“±ê¸‰ (í™•ë¥ : {probs[0].tolist()})")
                    print(f"   - ì˜ˆì¸¡ìˆ˜ì¹˜({len(reg_values)}ê°œ): {[round(x, 3) for x in reg_values]}")

                    # ì ìˆ˜ ë³€í™˜ (UI í‘œì‹œìš©) - ê°œì„ ëœ ì•Œê³ ë¦¬ì¦˜
                    max_grade = config["num_classes"]

                    # 1. ê¸°ë³¸ ì ìˆ˜ ê³„ì‚° (ë“±ê¸‰ ê¸°ë°˜)
                    base_score = ((max_grade - grade + 1) / max_grade) * 100

                    # 2. Regression ê°’ì„ í™œìš©í•˜ì—¬ ì„¸ë°€í•œ ì ìˆ˜ ì¡°ì •
                    # ì£¼ìš” ì§€í‘œ(ìƒìœ„ 5ê°œ)ì˜ í‰ê· ì„ ë³´ì •ê°’ìœ¼ë¡œ ì‚¬ìš©
                    if len(reg_values) > 0:
                        # 0-10 ë²”ìœ„ë¥¼ ê°€ì •í•˜ê³  ì •ê·œí™”
                        normalized_metrics = [max(0, min(10, abs(val))) for val in reg_values[:5]]
                        avg_metric = sum(normalized_metrics) / len(normalized_metrics) if normalized_metrics else 5

                        # ë³´ì •ê°’: -10 ~ +10 ë²”ìœ„
                        adjustment = (avg_metric - 5) * 2  # 5ê°€ ì¤‘ê°„ê°’
                    else:
                        adjustment = 0

                    # 3. ìµœì¢… ì ìˆ˜ (ì†Œìˆ˜ì  í¬í•¨, ë°˜ì˜¬ë¦¼)
                    score = round(max(0, min(100, base_score + adjustment)))
                    chart_grade = max(1, min(10, int(score / 10)))

                    # ìƒì„¸ ë©”íŠ¸ë¦­ íŒŒì‹±
                    detailed_metrics = parse_regression_values(region_name, reg_values)

                    results[region_name] = {
                        "grade": chart_grade,
                        "raw_grade": grade,
                        "score": score,
                        "details": reg_values,
                        "metrics": detailed_metrics  # ìƒˆë¡œ ì¶”ê°€ëœ ìƒì„¸ ë¶„ì„
                    }
                    total_grade_sum += score
                    count += 1
            else:
                print(f"âš ï¸ [{region_name}] ëª¨ë¸ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
                results[region_name] = {"grade": 5, "score": 50, "metrics": {}}

        overall_score = int(total_grade_sum / count) if count > 0 else 0

        # AI ê¸°ë°˜ LED ì†”ë£¨ì…˜ ì¶”ì²œ
        analysis_data = {
            "overall_score": overall_score,
            "regions": results
        }
        recommendation = LEDRecommendationEngine.recommend(analysis_data)

        print("="*50)
        print(f"âœ… ë¶„ì„ ì™„ë£Œ! ì¢…í•© ì ìˆ˜: {overall_score}")
        print(f"ğŸ’¡ ì¶”ì²œ ì†”ë£¨ì…˜: {recommendation['mode'].upper()} ëª¨ë“œ ({recommendation['duration']}ë¶„)")
        print(f"   ì´ìœ : {recommendation['reason']}")
        print("="*50 + "\n")

        response_data = {
            "overall_score": overall_score,
            "regions": results,
            "recommendation": recommendation,  # AI ì¶”ì²œ ì¶”ê°€
            "timestamp": datetime.now().isoformat()
        }

        return jsonify(response_data)

    except Exception as e:
        print(f"âŒ ì¹˜ëª…ì  ì˜¤ë¥˜ ë°œìƒ: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500

# ==========================================
# íˆìŠ¤í† ë¦¬ ê´€ë¦¬ API
# ==========================================
@app.route('/api/v1/history', methods=['POST'])
def save_history():
    """ë¶„ì„ ê²°ê³¼ë¥¼ íˆìŠ¤í† ë¦¬ì— ì €ì¥ (PostgreSQL)"""
    db = get_db()
    try:
        data = request.get_json()
        user_id = data.get('user_id', 'anonymous')

        # í•„ìˆ˜ í•„ë“œ í™•ì¸
        if 'overall_score' not in data or 'regions' not in data:
            return jsonify({"error": "Missing required fields"}), 400

        # ìƒˆ ê¸°ë¡ ìƒì„±
        new_record = AnalysisHistory(
            user_id=user_id,
            timestamp=datetime.fromisoformat(data.get('timestamp', datetime.now().isoformat()).replace('Z', '+00:00')) if isinstance(data.get('timestamp'), str) else datetime.now(),
            overall_score=data['overall_score'],
            regions=data['regions'],
            recommendation=data.get('recommendation', {}),
            course_name=data.get('course_name', 'AI ì •ë°€ ë¶„ì„')
        )

        db.add(new_record)
        db.commit()
        db.refresh(new_record)

        print(f"ğŸ“ íˆìŠ¤í† ë¦¬ ì €ì¥ ì™„ë£Œ: {user_id} - ì ìˆ˜ {data['overall_score']}")

        return jsonify({
            "success": True,
            "record_id": new_record.id,
            "message": "íˆìŠ¤í† ë¦¬ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤."
        })

    except Exception as e:
        db.rollback()
        print(f"âŒ íˆìŠ¤í† ë¦¬ ì €ì¥ ì˜¤ë¥˜: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route('/api/v1/history/<user_id>', methods=['GET'])
def get_history(user_id):
    """ì‚¬ìš©ìë³„ íˆìŠ¤í† ë¦¬ ì¡°íšŒ (PostgreSQL)"""
    db = get_db()
    try:
        # ìµœëŒ€ ê°œìˆ˜ ì œí•œ (ì„ íƒì )
        limit = request.args.get('limit', type=int, default=20)

        # ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ (ìµœì‹ ìˆœ)
        records = db.query(AnalysisHistory)\
            .filter(AnalysisHistory.user_id == user_id)\
            .order_by(AnalysisHistory.timestamp.desc())\
            .limit(limit)\
            .all()

        # ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
        user_history = [record.to_dict() for record in records]

        return jsonify({
            "user_id": user_id,
            "total_records": len(user_history),
            "history": user_history
        })

    except Exception as e:
        print(f"âŒ íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì˜¤ë¥˜: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


# ==========================================
# ì‚¬ìš©ì í”„ë¡œí•„ ê´€ë¦¬ API
# ==========================================
@app.route('/api/v1/user/profile', methods=['POST'])
def save_user_profile():
    """ì‚¬ìš©ì í”„ë¡œí•„ ìƒì„±/ìˆ˜ì • (PostgreSQL)"""
    db = get_db()
    try:
        data = request.get_json()
        user_id = data.get('user_id')

        if not user_id:
            return jsonify({"error": "user_id is required"}), 400

        # ê¸°ì¡´ ì‚¬ìš©ì ì¡°íšŒ
        existing_user = db.query(User).filter(User.user_id == user_id).first()

        if existing_user:
            # ì—…ë°ì´íŠ¸
            existing_user.name = data.get('name', existing_user.name)
            existing_user.skin_type = data.get('skin_type', existing_user.skin_type)
            existing_user.concerns = data.get('concerns', existing_user.concerns)
            existing_user.goals = data.get('goals', existing_user.goals)
            existing_user.updated_at = datetime.now()

            db.commit()
            db.refresh(existing_user)
            profile = existing_user.to_dict()
        else:
            # ìƒˆ ì‚¬ìš©ì ìƒì„±
            new_user = User(
                user_id=user_id,
                name=data.get('name', ''),
                skin_type=data.get('skin_type', ''),
                concerns=data.get('concerns', []),
                goals=data.get('goals', '')
            )
            db.add(new_user)
            db.commit()
            db.refresh(new_user)
            profile = new_user.to_dict()

        print(f"ğŸ‘¤ í”„ë¡œí•„ ì €ì¥ ì™„ë£Œ: {user_id} - {profile.get('name', 'N/A')}")

        return jsonify({
            "success": True,
            "profile": profile
        })

    except Exception as e:
        db.rollback()
        print(f"âŒ í”„ë¡œí•„ ì €ì¥ ì˜¤ë¥˜: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route('/api/v1/user/profile/<user_id>', methods=['GET'])
def get_user_profile(user_id):
    """ì‚¬ìš©ì í”„ë¡œí•„ ì¡°íšŒ (PostgreSQL)"""
    db = get_db()
    try:
        user = db.query(User).filter(User.user_id == user_id).first()

        if not user:
            return jsonify({
                "user_id": user_id,
                "profile": None,
                "message": "í”„ë¡œí•„ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
            }), 404

        return jsonify({
            "user_id": user_id,
            "profile": user.to_dict()
        })

    except Exception as e:
        print(f"âŒ í”„ë¡œí•„ ì¡°íšŒ ì˜¤ë¥˜: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


# ==========================================
# í†µê³„ API
# ==========================================
@app.route('/api/v1/stats/<user_id>', methods=['GET'])
def get_user_stats(user_id):
    """ì‚¬ìš©ì í†µê³„ (í‰ê·  ì ìˆ˜, ê°œì„  ì¶”ì´ ë“±) (PostgreSQL)"""
    db = get_db()
    try:
        # ì‚¬ìš©ì ê¸°ë¡ ì¡°íšŒ (ìµœì‹ ìˆœ)
        records = db.query(AnalysisHistory)\
            .filter(AnalysisHistory.user_id == user_id)\
            .order_by(AnalysisHistory.timestamp.desc())\
            .all()

        if not records:
            return jsonify({
                "user_id": user_id,
                "message": "ë¶„ì„ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤."
            }), 404

        # í†µê³„ ê³„ì‚°
        scores = [r.overall_score for r in records]

        # ìµœê·¼ 7ê°œ ê¸°ë¡ìœ¼ë¡œ ì¶”ì„¸ ê³„ì‚°
        recent_scores = scores[:7]
        trend = "improving" if len(recent_scores) >= 2 and recent_scores[0] > recent_scores[-1] else "stable"

        # ë¶€ìœ„ë³„ í‰ê·  ì ìˆ˜
        region_stats = {}
        for region in ["forehead", "eye_l", "eye_r", "cheek_l", "cheek_r", "chin"]:
            region_scores = [
                r.regions[region]['score']
                for r in records
                if r.regions and region in r.regions
            ]
            if region_scores:
                region_stats[region] = {
                    "average": round(sum(region_scores) / len(region_scores), 2),
                    "latest": region_scores[0],
                    "best": max(region_scores)
                }

        stats = {
            "user_id": user_id,
            "total_analyses": len(records),
            "average_score": round(sum(scores) / len(scores), 2) if scores else 0,
            "latest_score": scores[0] if scores else 0,
            "best_score": max(scores) if scores else 0,
            "trend": trend,
            "improvement": round(scores[0] - scores[-1], 2) if len(scores) >= 2 else 0,
            "region_stats": region_stats,
            "recent_scores": recent_scores
        }

        return jsonify(stats)

    except Exception as e:
        print(f"âŒ í†µê³„ ì¡°íšŒ ì˜¤ë¥˜: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


# ==========================================
# BLE ë””ë°”ì´ìŠ¤ ì„¤ì • API (Seeed Xiao BLEìš©)
# ==========================================
@app.route('/api/v1/device/config', methods=['GET'])
def get_device_config():
    """Seeed Xiao BLE ë””ë°”ì´ìŠ¤ ì„¤ì • ë°˜í™˜"""
    config = LEDRecommendationEngine.get_device_config()
    return jsonify(config)


@app.route('/api/v1/device/modes', methods=['GET'])
def get_led_modes():
    """ì‚¬ìš© ê°€ëŠ¥í•œ LED ëª¨ë“œ ì •ë³´ ë°˜í™˜"""
    return jsonify({
        "modes": LEDRecommendationEngine.LED_MODES,
        "description": "ê° LED ëª¨ë“œë³„ íŒŒì¥ê³¼ íš¨ê³¼ ì •ë³´"
    })


if __name__ == '__main__':
    app.run(debug=True, port=5000)